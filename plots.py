import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np


def _print_tex(fig, caption="Plot", label="fig:plot"):
    """
    Helper to print TikZ code for a matplotlib figure.
    """
    try:
        import tikzplotlib
        
        # Get TikZ code
        tikz_code = tikzplotlib.get_tikz_code(figure=fig, include_disclaimer=False)
        
        print("\n" + "%" * 40)
        print(f"% LaTeX Code for {caption}")
        print("%" * 40)
        print("\\begin{figure}")
        print("  \\centering")
        print(tikz_code)
        # print(f"  \\caption{{{caption}}}")
        # print(f"  \\label{{{label}}}")
        print("\\end{figure}")
        print("%" * 40 + "\n")
        
    except ImportError:
        print("\n[Warning] tikzplotlib not installed. Cannot print LaTeX code.")
        print("Install with: pip install tikzplotlib\n")
    except Exception as e:
        print(f"\n[Error] Could not generate TikZ code: {e}\n")


def los_initial_plot(data_dict, normalize_by_focus=False, print_tex=False):
    """
    Creates a split violin plot with dots for Length of Stay data.
    
    Args:
        data_dict: Dictionary with result data (as generated by loop_main.py)
        normalize_by_focus: If True, divides sum_focus_los by D_focus
        print_tex: If True, prints the LaTeX figure environment code
    """
    # Convert dictionary to DataFrame
    df = pd.DataFrame(data_dict)
    
    # ==========================================
    # DATA CLEANING & PREPARATION
    # ==========================================
    
    # Optional: Normalize
    y_col = "sum_focus_los"
    y_label = "Focus Length of Stay (Days)"
    
    if normalize_by_focus:
        # Check column name (D_focus or D_focus_count)
        if 'D_focus' in df.columns:
            d_col = 'D_focus'
        elif 'D_focus_count' in df.columns:
            d_col = 'D_focus_count'
        else:
            print("Warning: Neither 'D_focus' nor 'D_focus_count' found. Skipping normalization.")
            d_col = None
            
        if d_col:
            # Ensure D_focus is numeric
            df[d_col] = pd.to_numeric(df[d_col], errors='coerce')
            # Create normalized column
            df['normalized_los'] = df['sum_focus_los'] / df[d_col]
            y_col = "normalized_los"
            y_label = "Avg Focus Length of Stay (Days per Patient)"
    
    # A. Mapping for OnlyHuman (1 = Human Only, 0 = Hybrid/App)
    df['Service_Model'] = df['OnlyHuman'].map({1: 'Human Only', 0: 'Hybrid (App)'})
    
    # B. Mapping for pttr (clean labels)
    pttr_mapping = {
        'light': 'Light',
        'mp': 'Medium',
        'medium': 'Medium',
        'heavy': 'Heavy'
    }
    df['pttr_clean'] = df['pttr'].map(pttr_mapping).fillna(df['pttr'])
    
    # C. Order for X-axis
    pttr_order = ['Light', 'Medium', 'Heavy']
    
    # ==========================================
    # PLOTTING (FACET GRID BY T & D)
    # ==========================================
    g = sns.catplot(
        data=df,
        kind="box",
        x="pttr_clean",
        y=y_col,
        hue="Service_Model",
        col="T",
        row="D",
        order=pttr_order,
        palette=['#FFC20A', '#0C7BDC'],  # Yellow (Human) / Blue (Hybrid)
        height=4,
        aspect=1.2,
        sharey=False,
        legend=False
    )
    
    g.set_axis_labels("Pttr", y_label)
    g.set_titles("")
    
    # Center X-axis labels under boxplot groups
    for ax in g.axes.flat:
        ax.set_xticks([0, 1, 2])
        ax.set_xticklabels(pttr_order)
    
    plt.tight_layout()
    
    if print_tex:
        _print_tex(g.figure, caption="LOS Initial Plot", label="fig:los_initial")
    
    return g


def sorted_savings_plot(data_dict, workload='heavy', print_tex=False):
    """
    Creates a line plot of savings (Human LOS - Hybrid LOS) sorted by magnitude.
    Now iterates over all seeds for the workload and picks the one with max std dev.
    
    Args:
        data_dict: Dictionary with result data
        workload: 'heavy', 'medium', or 'light'
        print_tex: If True, prints the LaTeX figure environment code
    """
    import ast
    
    # Convert to DataFrame
    df = pd.DataFrame(data_dict)
    
    # Filter by workload
    subset = df[df['pttr'] == workload].copy()
    
    if subset.empty:
        print(f"Warning: No data found for workload '{workload}'")
        return None
    
    # If using 'medium', treat 'mp' as 'medium' just in case
    # (Though logic above is based on exact match of 'pttr')
    
    # Since we might have multiple iterations or entries, we need to pick pairs.
    # We assume 'seed' + 'OnlyHuman' identifies a unique run.
    
    if 'focus_los' not in subset.columns:
        print("Warning: 'focus_los' column missing.")
        return None

    # ==========================================
    # SELECT SEED WITH MAX STD DEV
    # ==========================================
    available_seeds = subset['seed'].unique()
    if len(available_seeds) == 0:
        print("Warning: No seeds available")
        return None
    
    best_seed = None
    max_std_dev = -1.0
    savings = []
    patient_ids = []
    
    def parse_los_dict(los_value):
        """Parse dict string to actual dict."""
        try:
            if isinstance(los_value, dict):
                return los_value
            elif isinstance(los_value, str):
                return ast.literal_eval(los_value)
            else:
                return {}
        except Exception:
            return {}

    print(f"Analyzing {len(available_seeds)} seeds for workload '{workload}'...")

    for current_seed in available_seeds:
        # Get rows for this seed
        human_row = subset[(subset['seed'] == current_seed) & (subset['OnlyHuman'] == 1)]
        hybrid_row = subset[(subset['seed'] == current_seed) & (subset['OnlyHuman'] == 0)]
        
        if human_row.empty or hybrid_row.empty:
            continue
            
        # Parse dicts
        try:
            human_dict = parse_los_dict(human_row['focus_los'].iloc[0])
            hybrid_dict = parse_los_dict(hybrid_row['focus_los'].iloc[0])
            
            # Create diff dict (Human - Hybrid for each patient key)
            common_keys = set(human_dict.keys()) & set(hybrid_dict.keys())
            if not common_keys:
                continue
                
            diff_values = [human_dict[k] - hybrid_dict[k] for k in common_keys]
            
            if not diff_values:
                continue
                
            std_dev = np.std(diff_values)
            
            if std_dev > max_std_dev:
                max_std_dev = std_dev
                best_seed = current_seed
                
                # Store data for plotting
                # Structure: (id, diff, old_los, new_los)
                sorted_items = sorted([(k, human_dict[k] - hybrid_dict[k], human_dict[k], hybrid_dict[k]) 
                                     for k in common_keys], key=lambda x: x[1])
                patient_ids = [item[0] for item in sorted_items]
                savings = [item[1] for item in sorted_items]
                human_los = [item[2] for item in sorted_items]
                hybrid_los = [item[3] for item in sorted_items]
        except Exception as e:
            print(f"Error processing seed {current_seed}: {e}")
            continue

    if best_seed is None:
        print("Warning: No valid seed found with matching Human/Hybrid pairs.")
        return None

    print(f"Selected Seed: {best_seed} with Max Std Dev: {max_std_dev:.4f}")
    
    seed = best_seed
    
    # ==========================================
    # PLOTTING
    # ==========================================
    fig, ax = plt.subplots(figsize=(12, 6))
    
    # Use patient IDs (as strings) for X-axis labels to avoid numeric formatting issues
    x_labels = [str(pid) for pid in patient_ids]
    x_pos = range(len(savings))
    
    # Plot bars
    bars = ax.bar(x_pos, savings, color='#0C7BDC', alpha=0.8, edgecolor='white')
    
    # Reference line at 0
    ax.axhline(0, color='red', linestyle='--', linewidth=1)
    
    workload_label = workload.capitalize() if workload else 'All'
    ax.set_xlabel('Patient ID', fontsize=12)
    ax.set_ylabel('Days Saved (Human LOS - Hybrid LOS)', fontsize=12)
    
    # Remove X-ticks labels as requested (Patient IDs removed)
    ax.set_xticks([]) 
    ax.set_xticklabels([])
    
    # Add value labels inside bars representing "Old / New"
    for i, bar in enumerate(bars):
        height = bar.get_height()
        if abs(height) > 0.1: 
             label_text = f"{human_los[i]} / {hybrid_los[i]}"
             # Center text in bar
             ax.text(bar.get_x() + bar.get_width()/2., height/2.,
                     label_text,
                     ha='center', va='center', rotation=90, fontsize=8, color='white')

    import matplotlib.ticker as ticker
    ax.yaxis.set_major_formatter(ticker.FormatStrFormatter('%.1f'))
    ax.grid(True, axis='y', linestyle=':', alpha=0.6)
    
    plt.tight_layout()
    
    if print_tex:
        _print_tex(fig, caption=f"Savings Distribution (Seed {seed})", label="fig:savings")
    
    return fig


# ==========================================
# MAIN (for testing)
# ==========================================
if __name__ == "__main__":
    import glob
    import os
    
    # Results directory
    results_dir = 'results/cg'
    excel_files = glob.glob(os.path.join(results_dir, '*.xlsx'))
    # Filter out temp files (starting with ~$)
    excel_files = [f for f in excel_files if not os.path.basename(f).startswith('~$')]
    
    if not excel_files:
        print(f"Error: No Excel files found in '{results_dir}'.")
    else:
        # Find the newest file
        newest_excel = max(excel_files, key=os.path.getmtime)
        print(f"Loading newest file: {newest_excel}")
        
        try:
            df = pd.read_excel(newest_excel)
            print("Data loaded successfully.")
            # Convert DataFrame to dict for function call
            data_dict = df.to_dict('list')
            
            # Plot 1: LOS Split Violin Plot
            los_initial_plot(data_dict, normalize_by_focus=True)
            
            # Plot 2: Sorted Savings Distribution
            sorted_savings_plot(data_dict, workload='heavy')
            
            plt.show()
            
        except Exception as e:
            print(f"Error loading file: {e}")