import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt


def los_initial_plot(data_dict):
    """
    Creates a boxplot for Length of Stay data.
    
    Args:
        data_dict: Dictionary with result data (as generated by loop_main.py)
    """
    # Convert dictionary to DataFrame
    df = pd.DataFrame(data_dict)
    
    # ==========================================
    # DATA CLEANING & PREPARATION
    # ==========================================
    
    # A. Mapping for OnlyHuman (1 = Human Only, 0 = Hybrid/App)
    df['Service_Model'] = df['OnlyHuman'].map({1: 'Human Only', 0: 'Hybrid (App)'})
    
    # B. Mapping for pttr (clean labels)
    pttr_mapping = {
        'light': 'Light',
        'mp': 'Medium',
        'medium': 'Medium',
        'heavy': 'Heavy'
    }
    df['pttr_clean'] = df['pttr'].map(pttr_mapping).fillna(df['pttr'])
    
    # C. Order for X-axis
    pttr_order = ['Light', 'Medium', 'Heavy']
    
    # ==========================================
    # PLOTTING (FACET GRID BY T & D)
    # ==========================================
    g = sns.catplot(
        data=df,
        kind="box",
        x="pttr_clean",
        y="final_ub",
        hue="Service_Model",
        col="T",
        row="D",
        order=pttr_order,
        palette=['#FFC20A', '#0C7BDC'],  # Yellow (Human) / Blue (Hybrid)
        height=4,
        aspect=1.2,
        sharey=False
    )
    
    g.set_axis_labels("Pttr", "Length of Stay (Days)")
    g.set_titles("")
    
    # Move legend below plot, horizontal layout
    sns.move_legend(
        g, "lower center",
        bbox_to_anchor=(0.5, -0.05),
        ncol=2,
        title="Service Model",
        frameon=True,
        edgecolor='black'
    )
    
    # Center X-axis labels under boxplot groups
    for ax in g.axes.flat:
        ax.set_xticks([0, 1, 2])
        ax.set_xticklabels(["Light", "Medium", "Heavy"], ha='center')
    
    plt.show()
    return g


def sorted_savings_plot(data_dict, workload='heavy', seed=None):
    """
    Creates a sorted savings distribution plot (Area plot).
    Compares focus_los dicts between Human-Only and Hybrid for a single seed.
    
    Args:
        data_dict: Dictionary with result data (as generated by loop_main.py)
        workload: Filter for workload scenario ('heavy', 'medium', 'light')
        seed: Specific seed to use (if None, picks a random one)
    
    Returns:
        matplotlib figure object
    """
    import ast
    import random
    
    # Convert dictionary to DataFrame
    df = pd.DataFrame(data_dict)
    
    # ==========================================
    # DATA FILTERING
    # ==========================================
    if workload:
        subset = df[df['pttr'].astype(str).str.lower() == workload.lower()].copy()
        if subset.empty:
            print(f"Warning: No data found for workload '{workload}'")
            return None
    else:
        subset = df.copy()
    
    # ==========================================
    # SELECT SEED
    # ==========================================
    available_seeds = subset['seed'].unique()
    if len(available_seeds) == 0:
        print("Warning: No seeds available")
        return None
    
    if seed is None:
        seed = random.choice(available_seeds)
    
    print(f"Using seed: {seed}")
    
    # Get rows for this seed
    human_row = subset[(subset['seed'] == seed) & (subset['OnlyHuman'] == 1)]
    hybrid_row = subset[(subset['seed'] == seed) & (subset['OnlyHuman'] == 0)]
    
    if human_row.empty or hybrid_row.empty:
        print(f"Warning: No matching Human/Hybrid pair for seed {seed}")
        return None
    
    # ==========================================
    # PARSE DICTS AND COMPUTE DIFF
    # ==========================================
    def parse_los_dict(los_value):
        """Parse dict string to actual dict."""
        try:
            if isinstance(los_value, dict):
                return los_value
            elif isinstance(los_value, str):
                return ast.literal_eval(los_value)
            else:
                return {}
        except Exception:
            return {}
    
    human_dict = parse_los_dict(human_row['focus_los'].iloc[0])
    hybrid_dict = parse_los_dict(hybrid_row['focus_los'].iloc[0])
    
    # Create diff dict (Human - Hybrid for each patient key)
    common_keys = set(human_dict.keys()) & set(hybrid_dict.keys())
    diff_dict = {k: human_dict[k] - hybrid_dict[k] for k in common_keys}
    
    if not diff_dict:
        print("Warning: No common patient keys found")
        return None
    
    # Sort by savings ascending
    sorted_items = sorted(diff_dict.items(), key=lambda x: x[1])
    patient_ids = [item[0] for item in sorted_items]
    savings = [item[1] for item in sorted_items]
    
    # Create percentile ranks
    n = len(savings)
    percentiles = [(i / n) * 100 for i in range(n)]
    
    # ==========================================
    # PLOTTING (BAR CHART)
    # ==========================================
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # Bar plot - sorted savings
    x_pos = range(len(savings))
    bars = ax.bar(x_pos, savings, color='#0C7BDC', alpha=0.8)
    
    # Color negative bars differently and add patient ID labels
    for i, bar in enumerate(bars):
        if savings[i] < 0:
            bar.set_color('#FFC20A')
        # Add patient ID label inside bar
        height = bar.get_height()
        label_y = height / 2 if abs(height) > 0.5 else height + 0.1 * (1 if height >= 0 else -1)
        ax.text(bar.get_x() + bar.get_width() / 2, label_y, 
                str(patient_ids[i]), ha='center', va='center', 
                fontsize=8, color='white' if abs(height) > 0.5 else 'black', fontweight='bold')
    
    # Reference line at 0
    ax.axhline(0, color='red', linestyle='--', linewidth=1)
    
    workload_label = workload.capitalize() if workload else 'All'
    #ax.set_title(f'Sorted Time Savings per Patient ({workload_label} Load, Seed: {seed})', fontsize=14)
    ax.set_xlabel('Sorted Patients', fontsize=12)
    ax.set_ylabel('Days Saved (Human LOS - Hybrid LOS)', fontsize=12)
    ax.grid(True, axis='y', linestyle=':', alpha=0.6)
    
    plt.tight_layout()
    plt.show()
    
    return fig


# ==========================================
# MAIN (for testing)
# ==========================================
if __name__ == "__main__":
    import glob
    import os
    
    # Results directory
    results_dir = 'results/cg'
    excel_files = glob.glob(os.path.join(results_dir, '*.xlsx'))
    # Filter out temp files (starting with ~$)
    excel_files = [f for f in excel_files if not os.path.basename(f).startswith('~$')]
    
    if not excel_files:
        print(f"Error: No Excel files found in '{results_dir}'.")
    else:
        # Find the newest file
        newest_excel = max(excel_files, key=os.path.getmtime)
        print(f"Loading newest file: {newest_excel}")
        
        try:
            df = pd.read_excel(newest_excel)
            print("Data loaded successfully.")
            # Convert DataFrame to dict for function call
            data_dict = df.to_dict('list')
            
            # Plot 1: LOS Boxplot
            los_initial_plot(data_dict)
            
            # Plot 2: Sorted Savings Distribution
            sorted_savings_plot(data_dict, workload='heavy', seed=1)
            
        except Exception as e:
            print(f"Error loading file: {e}")